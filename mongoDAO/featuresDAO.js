

var constants = require("./MapReduceConstantsNode.js");

//Library used to retrieve mock data from json files
var jsonQuery = require('json-query')

function cleanUp() {
  constants.closeConnection();
}

/**
 * TEST function. It returns a set of "feature events".
 * This test returns all occurrences of "right click"
 * example query:
 * db.events.find({sid: "w62zkMya3kBE", timestampms: {$gte: "1454136343379",$lte: "1456137344379"},event: "mousedown",button: "r"})
 * The upcoming functions should work using the same set of parameters:
 * @param userID
 * @param featureName
 * @param startTimestamp EPOCH
 * @param endTimestamp EPOCH
 */

function testFeatureQuery(userID, featureName, startTimestamp, endTimestamp, callback) {
  console.log("featuresDAO:testFeatureQuery()");

  constants.connectAndValidateNodeJs(function (err, db) {
    if (err) return console.error("testFeatureQuery() ERROR connecting to DB" + err);
    console.log("featuresDAO:testFeatureQuery() running the query with the following parameters:");
    console.log(userID + ":" + typeof (userID));
    console.log(startTimestamp + ":" + typeof (startTimestamp));
    console.log(endTimestamp + ":" + typeof (endTimestamp));
    //Construct the query
    db.collection(constants.eventCollection).find({
      sid: userID,
      timestampms: {
        $gte: startTimestamp,
        $lte: endTimestamp
      },
      event: "mousedown",
      button: "r"
    }).toArray(function (err, featuresList) {
      console.log("featuresDAO:testFeatureQuery() Query ended");
      callback(null, featuresList);
    });
  });
}


function mockFeatureQuery(userID, featureName, startTimestamp, endTimestamp, callback) {
  console.log("featuresDAO:mockFeatureQuery()");

  constants.connectAndValidateNodeJs(function (err, db) {
    if (err) return console.error("testFeatureQuery() ERROR connecting to DB" + err);

    var fs = require('fs');
    var parsedJSON = JSON.parse(fs.readFileSync('./mongoDAO/testData.json', 'utf8'));

    console.log("featuresDAO.js: mockFeatureQuery Query ended");
    callback(null, parsedJSON);
  });
}

/**
 * Given a series of optional parameters, creates a JSON query and retrieves the
 * matching documents
 * @param {*} userID 
 * @param {*} startTimestamp 
 * @param {*} endTimestamp 
 * @param {*} callback 
 */
function mockATSEventsQuery(userID, startTimestamp, endTimestamp, callback) {
  console.log("featuresDAO:mockFeatureQuery()");


  var fs = require('fs');
  var parsedJSON = JSON.parse(fs.readFileSync('./mongoDAO/mock_data.json', 'utf8'));

  //The following query returns all events generated by "aristoteles"
  //jsonQuery("[*sid=aristoteles]", { data: parsedJSON }).value

  //generate the query based on the input data
  var query = "[*";
  //if the parameter has a value, add it to the string query, otherwise, leave it as it is
  query += typeof userID !== 'undefined' ? ("sid=" + userID.toString() + "&") : "";
  query += typeof startTimestamp !== 'undefined' ? ("timestampms>=" + startTimestamp.toString() + "&") : "";
  query += typeof endTimestamp !== 'undefined' ? ("timestampms<=" + endTimestamp.toString() + "&") : "";

  //remove last "&"
  query = query.substring(0, query.length - 1);
  query += "]";

  console.log(query);

  //jsonQuery.query("query", {data: parsedJSON}).value
  var result = jsonQuery(query, { data: parsedJSON }).value;
  callback(null, result);

}

/**
 * Same as mockATSEventsQuery, but takes an additional parameter, indicating the 
 * number of random documents to return from the results
 * @param {*} userID 
 * @param {*} startTimestamp 
 * @param {*} endTimestamp 
 * @param {int} numberOfDocs
 * @param {*} callback 
 */
function mockATSEventsQueryRandom(userID, startTimestamp, endTimestamp, numberOfDocs, callback) {
  console.log("featuresDAO:mockATSEventsQueryRandom()");
  mockATSEventsQuery(userID, startTimestamp, endTimestamp, function(err,resultArray){
    var randomResults = [];
    while (numberOfDocs>0 && resultArray.length>0){
      var randomIndex = Math.floor(Math.random()*resultArray.length);
      randomResults.push(resultArray[randomIndex]);
      //remove the returned value, we don't want duplicates
      resultArray.splice(randomIndex,1);
      numberOfDocs--;
    }
    //Once the results are retrieved, pick a random set of values
    callback(null, randomResults);
  });
}

module.exports.cleanUp = cleanUp;
module.exports.testFeatureQuery = testFeatureQuery;
module.exports.mockFeatureQuery = mockFeatureQuery;
module.exports.mockATSEventsQuery = mockATSEventsQuery;
module.exports.mockATSEventsQueryRandom = mockATSEventsQueryRandom;